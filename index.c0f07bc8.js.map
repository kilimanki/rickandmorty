{"mappings":"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","sources":["node_modules/animated-scroll-to/dist/esm/index.js","js/master.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// --------- HELPERS\nfunction getElementOffset(el) {\n    let top = 0;\n    let left = 0;\n    let element = el;\n    // Loop through the DOM tree\n    // and add it's parent's offset to get page offset\n    do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n    } while (element);\n    return {\n        top,\n        left,\n    };\n}\n// --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\nclass ScrollDomElement {\n    constructor(element) {\n        this.element = element;\n    }\n    getHorizontalScroll() {\n        return this.element.scrollLeft;\n    }\n    getVerticalScroll() {\n        return this.element.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return this.element.scrollWidth - this.element.clientWidth;\n    }\n    getMaxVerticalScroll() {\n        return this.element.scrollHeight - this.element.clientHeight;\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).left -\n            getElementOffset(elementToScroll).left);\n    }\n    getVerticalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).top -\n            getElementOffset(elementToScroll).top);\n    }\n    scrollTo(x, y) {\n        this.element.scrollLeft = x;\n        this.element.scrollTop = y;\n    }\n}\nclass ScrollWindow {\n    constructor() {\n        this.element = window;\n    }\n    getHorizontalScroll() {\n        return window.scrollX || document.documentElement.scrollLeft;\n    }\n    getVerticalScroll() {\n        return window.scrollY || document.documentElement.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return (Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth);\n    }\n    getMaxVerticalScroll() {\n        return (Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight);\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo) {\n        const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n    }\n    getVerticalElementScrollOffset(elementToScrollTo) {\n        const scrollTop = window.scrollY || document.documentElement.scrollTop;\n        return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n    }\n    scrollTo(x, y) {\n        window.scrollTo(x, y);\n    }\n}\nconst activeAnimations = {\n    elements: [],\n    cancelMethods: [],\n    add: (element, cancelAnimation) => {\n        activeAnimations.elements.push(element);\n        activeAnimations.cancelMethods.push(cancelAnimation);\n    },\n    remove: (element, shouldStop) => {\n        const index = activeAnimations.elements.indexOf(element);\n        if (index > -1) {\n            // Stop animation\n            if (shouldStop) {\n                activeAnimations.cancelMethods[index]();\n            }\n            // Remove it\n            activeAnimations.elements.splice(index, 1);\n            activeAnimations.cancelMethods.splice(index, 1);\n        }\n    },\n};\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n// --------- ANIMATE SCROLL TO\nconst defaultOptions = {\n    cancelOnUserAction: true,\n    easing: (t) => --t * t * t + 1,\n    elementToScroll: WINDOW_EXISTS ? window : null,\n    horizontalOffset: 0,\n    maxDuration: 3000,\n    minDuration: 250,\n    speed: 500,\n    verticalOffset: 0,\n};\nfunction animateScrollTo(numberOrCoordsOrElement, userOptions = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Check for server rendering\n        if (!WINDOW_EXISTS) {\n            // @ts-ignore\n            // If it still gets called on server, return Promise for API consistency\n            return new Promise((resolve) => {\n                resolve(false); // Returning false on server\n            });\n        }\n        else if (!window.Promise) {\n            throw \"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.\";\n        }\n        let x;\n        let y;\n        let scrollToElement;\n        let options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n        const isWindow = options.elementToScroll === window;\n        const isElement = !!options.elementToScroll.nodeName;\n        if (!isWindow && !isElement) {\n            throw 'Element to scroll needs to be either window or DOM element.';\n        }\n        // Check for \"scroll-behavior: smooth\" as it can break the animation\n        // https://github.com/Stanko/animated-scroll-to/issues/55\n        const scrollBehaviorElement = isWindow\n            ? document.documentElement\n            : options.elementToScroll;\n        const scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n        if (scrollBehavior === 'smooth') {\n            console.warn(`${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`);\n        }\n        // Select the correct scrolling interface\n        const elementToScroll = isWindow\n            ? new ScrollWindow()\n            : new ScrollDomElement(options.elementToScroll);\n        if (numberOrCoordsOrElement instanceof Element) {\n            scrollToElement = numberOrCoordsOrElement;\n            // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n            if (isElement &&\n                (!options.elementToScroll.contains(scrollToElement) ||\n                    options.elementToScroll.isSameNode(scrollToElement))) {\n                throw 'options.elementToScroll has to be a parent of scrollToElement';\n            }\n            x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n            y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n        }\n        else if (typeof numberOrCoordsOrElement === 'number') {\n            x = elementToScroll.getHorizontalScroll();\n            y = numberOrCoordsOrElement;\n        }\n        else if (Array.isArray(numberOrCoordsOrElement) &&\n            numberOrCoordsOrElement.length === 2) {\n            x =\n                numberOrCoordsOrElement[0] === null\n                    ? elementToScroll.getHorizontalScroll()\n                    : numberOrCoordsOrElement[0];\n            y =\n                numberOrCoordsOrElement[1] === null\n                    ? elementToScroll.getVerticalScroll()\n                    : numberOrCoordsOrElement[1];\n        }\n        else {\n            // ERROR\n            throw ('Wrong function signature. Check documentation.\\n' +\n                'Available method signatures are:\\n' +\n                '  animateScrollTo(y:number, options)\\n' +\n                '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n                '  animateScrollTo(scrollToElement:Element, options)');\n        }\n        // Add offsets\n        x += options.horizontalOffset;\n        y += options.verticalOffset;\n        // Horizontal scroll distance\n        const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n        const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (x > maxHorizontalScroll) {\n            x = maxHorizontalScroll;\n        }\n        // Calculate distance to scroll\n        const horizontalDistanceToScroll = x - initialHorizontalScroll;\n        // Vertical scroll distance distance\n        const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n        const initialVerticalScroll = elementToScroll.getVerticalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (y > maxVerticalScroll) {\n            y = maxVerticalScroll;\n        }\n        // Calculate distance to scroll\n        const verticalDistanceToScroll = y - initialVerticalScroll;\n        // Calculate duration of the scroll\n        const horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n        const verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n        let duration = horizontalDuration > verticalDuration\n            ? horizontalDuration\n            : verticalDuration;\n        // Set minimum and maximum duration\n        if (duration < options.minDuration) {\n            duration = options.minDuration;\n        }\n        else if (duration > options.maxDuration) {\n            duration = options.maxDuration;\n        }\n        // @ts-ignore\n        return new Promise((resolve, reject) => {\n            // Scroll is already in place, nothing to do\n            if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n                // Resolve promise with a boolean hasScrolledToPosition set to true\n                resolve(true);\n            }\n            // Cancel existing animation if it is already running on the same element\n            activeAnimations.remove(elementToScroll.element, true);\n            // To cancel animation we have to store request animation frame ID\n            let requestID;\n            // Cancel animation handler\n            const cancelAnimation = () => {\n                removeListeners();\n                cancelAnimationFrame(requestID);\n                // Resolve promise with a boolean hasScrolledToPosition set to false\n                resolve(false);\n            };\n            // Registering animation so it can be canceled if function\n            // gets called again on the same element\n            activeAnimations.add(elementToScroll.element, cancelAnimation);\n            // Prevent user actions handler\n            const preventDefaultHandler = (e) => e.preventDefault();\n            const handler = options.cancelOnUserAction\n                ? cancelAnimation\n                : preventDefaultHandler;\n            // If animation is not cancelable by the user, we can't use passive events\n            const eventOptions = options.cancelOnUserAction\n                ? { passive: true }\n                : { passive: false };\n            const events = ['wheel', 'touchstart', 'keydown', 'mousedown'];\n            // Function to remove listeners after animation is finished\n            const removeListeners = () => {\n                events.forEach((eventName) => {\n                    elementToScroll.element.removeEventListener(eventName, handler, eventOptions);\n                });\n            };\n            // Add listeners\n            events.forEach((eventName) => {\n                elementToScroll.element.addEventListener(eventName, handler, eventOptions);\n            });\n            // Animation\n            const startingTime = Date.now();\n            const step = () => {\n                var timeDiff = Date.now() - startingTime;\n                var t = timeDiff / duration;\n                const horizontalScrollPosition = Math.round(initialHorizontalScroll +\n                    horizontalDistanceToScroll * options.easing(t));\n                const verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));\n                if (timeDiff < duration &&\n                    (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n                    // If scroll didn't reach desired position or time is not elapsed\n                    // Scroll to a new position\n                    elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n                    // And request a new step\n                    requestID = requestAnimationFrame(step);\n                }\n                else {\n                    // If the time elapsed or we reached the desired offset\n                    // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n                    // Clear animation frame to be sure\n                    elementToScroll.scrollTo(x, y);\n                    cancelAnimationFrame(requestID);\n                    // Remove listeners\n                    removeListeners();\n                    // Remove animation from the active animations coordinator\n                    activeAnimations.remove(elementToScroll.element, false);\n                    // Resolve promise with a boolean hasScrolledToPosition set to true\n                    resolve(true);\n                }\n            };\n            // Start animating scroll\n            requestID = requestAnimationFrame(step);\n        });\n    });\n}\nexport default animateScrollTo;\n","import animateScrollTo from 'animated-scroll-to';\nconst msNav = document.querySelector('.ms-nav');\n\nmsNav.addEventListener('click', e => {\n  const imageRotated = document.querySelector('.rotate-image');\n  const text = document.createElement('p');\n  text.classList.add('rotate-text');\n  text.textContent = 'Hello ! i`m ur master of navigation';\n  imageRotated.style.opacity = '1';\n  document.querySelector('.facts').style.opacity = '0';\n\n  text.setAttribute(\n    'style',\n    'position:absolute; top:50%; left:50%; color:white'\n  );\n  document.body.style.backgroundColor = 'black';\n  document.querySelector('header').style.opacity = '0.5';\n  document.querySelector('main').style.opacity = '0.5';\n  document.querySelector('footer').style.opacity = '0.5';\n  document.querySelector('header').style.pointerEvents = 'none';\n  document.querySelector('main').style.pointerEvents = 'none';\n  document.querySelector('footer').style.pointerEvents = 'none';\n  document.querySelector('.for-next').style.opacity = '0';\n\n  document.body.insertAdjacentElement('beforeend', text);\n  setTimeout(() => {\n    imageRotated.classList.add('rotate');\n    text.textContent = 'Here u can see our site navigation';\n    document.querySelector('header').style.opacity = '1';\n    text.classList.add('rotate');\n\n    document.querySelector('.nav-bar').style.animation =\n      'colorNav 1s infinite alternate';\n  }, 1000);\n  setTimeout(() => {\n    const btnK = document.createElement('button');\n    btnK.textContent = 'Ok';\n    btnK.setAttribute('style', 'position:absolute; top:5%; left:50%; ');\n    document.body.insertAdjacentElement('afterbegin', btnK);\n    btnK.addEventListener('click', e => {\n      const cord = document.querySelector('.random-btn');\n      animateScrollTo(cord, 3000);\n      imageRotated.classList.add('second-rotate');\n      imageRotated.classList.remove('rotate');\n      document.querySelector('.facts').style.opacity = '1';\n      text.setAttribute(\n        'style',\n        'top: 100%; left: 20%; position: absolute; color:white'\n      );\n      text.classList.remove('rotate');\n      text.classList.add('second-rotate-text');\n      document.querySelector('.for-next').style.opacity = '1';\n      text.textContent = 'U can get some facts and watch trailer of new season';\n      const nextButton = document.createElement('button');\n      nextButton.setAttribute(\n        'style',\n        'position:absolute; top:120%; left:30%; '\n      );\n      btnK.remove();\n      document.body.insertAdjacentElement('afterbegin', nextButton);\n      nextButton.textContent = 'Got it!';\n      document.querySelector('main').style.opacity = '1';\n      nextButton.addEventListener('click', e => {\n        document.querySelector('footer').style.opacity = '1';\n        document.querySelector('header').style.pointerEvents = 'all';\n        document.querySelector('main').style.pointerEvents = 'all';\n        document.querySelector('footer').style.pointerEvents = 'all';\n        imageRotated.classList.remove('second-rotate');\n        imageRotated.classList.add('rotate');\n        nextButton.remove();\n        imageRotated.style.opacity = '0';\n        text.remove();\n        // msNav.remove();\n        document.querySelector('.nav-bar').style.animation = 'none';\n      });\n    });\n  }, 2000);\n});\n"],"names":["$189aa83c3e1c4207$var$__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","$189aa83c3e1c4207$var$getElementOffset","el","top","left","element","offsetTop","offsetLeft","offsetParent","$189aa83c3e1c4207$var$ScrollDomElement","getHorizontalScroll","this","scrollLeft","getVerticalScroll","scrollTop","getMaxHorizontalScroll","scrollWidth","clientWidth","getMaxVerticalScroll","scrollHeight","clientHeight","getHorizontalElementScrollOffset","elementToScrollTo","elementToScroll","getVerticalElementScrollOffset","scrollTo","x","y","constructor","$189aa83c3e1c4207$var$ScrollWindow","window","scrollX","document","documentElement","scrollY","Math","max","body","offsetWidth","innerWidth","offsetHeight","innerHeight","getBoundingClientRect","$189aa83c3e1c4207$var$activeAnimations","elements","cancelMethods","add","cancelAnimation","push","remove","shouldStop","index","indexOf","splice","$189aa83c3e1c4207$var$WINDOW_EXISTS","$189aa83c3e1c4207$var$defaultOptions","cancelOnUserAction","easing","t","horizontalOffset","maxDuration","minDuration","speed","verticalOffset","$189aa83c3e1c4207$export$2e2bcd8739ae039","numberOrCoordsOrElement","userOptions","scrollToElement","options","Object","assign","isWindow","isElement","nodeName","scrollBehaviorElement","getComputedStyle","getPropertyValue","console","warn","tagName","Element","contains","isSameNode","Array","isArray","length","maxHorizontalScroll","initialHorizontalScroll","horizontalDistanceToScroll","maxVerticalScroll","initialVerticalScroll","verticalDistanceToScroll","horizontalDuration","abs","round","verticalDuration","duration","requestID","removeListeners","cancelAnimationFrame","handler","preventDefault","eventOptions","passive","events","forEach","eventName","removeEventListener","addEventListener","startingTime","Date","now","timeDiff","horizontalScrollPosition","verticalScrollPosition","requestAnimationFrame","querySelector","imageRotated","text","createElement","classList","textContent","style","opacity","setAttribute","backgroundColor","pointerEvents","insertAdjacentElement","setTimeout","animation","btnK","cord","$189aa83c3e1c4207$exports","default","nextButton"],"version":3,"file":"index.c0f07bc8.js.map"}