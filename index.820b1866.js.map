{"mappings":"+tBAAA,IAAAA,EAAAC,EAAA,S,0BAAIC,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,G,CAAW,MAAOG,GAAKL,EAAOK,E,EACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,G,CAAW,MAAOG,GAAKL,EAAOK,E,EACvF,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,E,KAITO,KAAKR,EAAWK,E,CAClGH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,O,KAItE,SAASO,EAAiBC,GACtB,IAAIC,EAAM,EACNC,EAAO,EACPC,EAAUH,EAGd,GACIC,GAAOE,EAAQC,WAAa,EAC5BF,GAAQC,EAAQE,YAAc,EAC9BF,EAAUA,EAAQG,mBACbH,GACT,MAAO,CACHF,MACAC,O,CAKR,IAAAK,EA6BI,W,sBA7BEC,EACUL,G,aACRM,KAAKN,QAAUA,C,iBAEnBO,IAAA,sB,MAAA,WACI,OAAOD,KAAKN,QAAQQ,U,IAExBD,IAAA,oB,MAAA,WACI,OAAOD,KAAKN,QAAQS,S,IAExBF,IAAA,yB,MAAA,WACI,OAAOD,KAAKN,QAAQU,YAAcJ,KAAKN,QAAQW,W,IAEnDJ,IAAA,uB,MAAA,WACI,OAAOD,KAAKN,QAAQY,aAAeN,KAAKN,QAAQa,Y,IAEpDN,IAAA,mC,MAAA,SAAiCO,EAAmBC,GAChD,OAAQnB,EAAiBkB,GAAmBf,KACxCH,EAAiBmB,GAAiBhB,I,IAE1CQ,IAAA,iC,MAAA,SAA+BO,EAAmBC,GAC9C,OAAQnB,EAAiBkB,GAAmBhB,IACxCF,EAAiBmB,GAAiBjB,G,IAE1CS,IAAA,W,MAAA,SAASS,EAAGC,GACRX,KAAKN,QAAQQ,WAAaQ,EAC1BV,KAAKN,QAAQS,UAAYQ,C,OAG7B,GAAJC,EA4BI,W,sBA5BEC,I,aAEEb,KAAKN,QAAUoB,M,iBAEnBb,IAAA,sB,MAAA,WACI,OAAOa,OAAOC,SAAWC,SAASC,gBAAgBf,U,IAEtDD,IAAA,oB,MAAA,WACI,OAAOa,OAAOI,SAAWF,SAASC,gBAAgBd,S,IAEtDF,IAAA,yB,MAAA,WACI,OAAQkB,KAAKC,IAAIJ,SAASK,KAAKjB,YAAaY,SAASC,gBAAgBb,YAAaY,SAASK,KAAKC,YAAaN,SAASC,gBAAgBK,YAAaN,SAASK,KAAKhB,YAAaW,SAASC,gBAAgBZ,aAAeS,OAAOS,U,IAEjOtB,IAAA,uB,MAAA,WACI,OAAQkB,KAAKC,IAAIJ,SAASK,KAAKf,aAAcU,SAASC,gBAAgBX,aAAcU,SAASK,KAAKG,aAAcR,SAASC,gBAAgBO,aAAcR,SAASK,KAAKd,aAAcS,SAASC,gBAAgBV,cAAgBO,OAAOW,W,IAEvOxB,IAAA,mC,MAAA,SAAiCO,GAE7B,OADmBM,OAAOC,SAAWC,SAASC,gBAAgBf,YAC1CM,EAAkBkB,wBAAwBjC,I,IAElEQ,IAAA,iC,MAAA,SAA+BO,GAE3B,OADkBM,OAAOI,SAAWF,SAASC,gBAAgBd,WAC1CK,EAAkBkB,wBAAwBlC,G,IAEjES,IAAA,W,MAAA,SAASS,EAAGC,GACRG,OAAOa,SAASjB,EAAGC,E,OAGvB,GAAEiB,EAAmB,CACrBC,SAAU,GACVC,cAAe,GACfC,IAAK,SAACrC,EAASsC,GACXJ,EAAiBC,SAASI,KAAKvC,GAC/BkC,EAAiBE,cAAcG,KAAKD,E,EAExCE,OAAQ,SAACxC,EAASyC,GACd,IAAMC,EAAQR,EAAiBC,SAASQ,QAAQ3C,GAC5C0C,GAAQ,IAEJD,GACAP,EAAiBE,cAAcM,KAGnCR,EAAiBC,SAASS,OAAOF,EAAO,GACxCR,EAAiBE,cAAcQ,OAAOF,EAAO,G,GAKnDG,EAAkC,oBAAXzB,OAEvB0B,EAAiB,CACnBC,oBAAoB,EACpBC,OAAQ,SAACC,G,QAAQA,EAAIA,EAAIA,EAAI,C,EAC7BlC,gBAAiB8B,EAAgBzB,OAAS,KAC1C8B,iBAAkB,EAClBC,YAAa,IACbC,YAAa,IACbC,MAAO,IACPC,eAAgB,G,IAqLpBC,EAnLA,SAAyBC,G,IAAyBC,EAAAC,UAAAC,OAAA,YAAAD,UAAA,GAAgBA,UAAA,GAAF,GAC5D,OAAOhF,EAAU4B,UAAM,OAAQ,EAAMsD,EAAAC,GAAAC,MAAE,SAAAC,I,IAY/B/C,EACAC,EACA+C,EACAC,EACEC,EACAC,EAMAC,EAQArD,EAyCAsD,EACAC,EAMAC,EAEAC,EACAC,EAMAC,EAEAC,EACAC,EACFC,E,qEA1FChC,EAAa,C,wCAGP,IAAI9D,SAAQ,SAACC,GAChBA,GAAQ,E,eAGNoC,OAAOrC,QAAO,C,eACpB,KAAM,qG,UAKNkF,EAAUa,OAAOC,OAAOD,OAAOC,OAAO,GAAIjC,GAAiBW,GACzDS,EAAWD,EAAQlD,kBAAoBK,OACvC+C,IAAcF,EAAQlD,gBAAgBiE,SACvCd,GAAaC,EAAS,C,gBACvB,KAAM,8D,WAIJC,EAAwBF,EACxB5C,SAASC,gBACT0C,EAAQlD,gBAES,WADAkE,iBAAiBb,GAAuBc,iBAAiB,oBAE5EC,QAAQC,KAAK,GAAiCC,OAA9BjB,EAAsBkB,QAAQ,2FAG5CvE,EAAkBmD,EAClB,IAAIhD,EACJ,IAAId,EAAiB6D,EAAQlD,mBAC/ByC,aAAmC+B,SAAO,C,mBAC1CvB,EAAkBR,GAEdW,GACEF,EAAQlD,gBAAgByE,SAASxB,KAC/BC,EAAQlD,gBAAgB0E,WAAWzB,GAAiB,C,gBACxD,KAAM,gE,QAEVhD,EAAID,EAAgB2E,iCAAiC1B,EAAiBC,EAAQlD,iBAC9EE,EAAIF,EAAgB4E,+BAA+B3B,EAAiBC,EAAQlD,iB,2BAEpC,iBAA5ByC,EAAoC,C,gBAChDxC,EAAID,EAAgB6E,sBACpB3E,EAAIuC,E,4BAECqC,MAAMC,QAAQtC,IACgB,IAAnCA,EAAwBG,OAAY,C,gBACpC3C,EACmC,OAA/BwC,EAAwB,GAClBzC,EAAgB6E,sBAChBpC,EAAwB,GAClCvC,EACmC,OAA/BuC,EAAwB,GAClBzC,EAAgBgF,oBAChBvC,EAAwB,G,wBAIlC,KAAO,8O,eAOXxC,GAAKiD,EAAQf,iBACbjC,GAAKgD,EAAQX,eAEPe,EAAsBtD,EAAgBiF,yBACtC1B,EAA0BvD,EAAgB6E,sBAE5C5E,EAAIqD,IACJrD,EAAIqD,GAGFE,EAA6BvD,EAAIsD,EAEjCE,EAAoBzD,EAAgBkF,uBACpCxB,EAAwB1D,EAAgBgF,oBAE1C9E,EAAIuD,IACJvD,EAAIuD,GAGFE,EAA2BzD,EAAIwD,EAE/BE,EAAqBlD,KAAKyE,IAAIzE,KAAK0E,MAAM5B,EAA8B,IAAQN,EAAQZ,QACvFuB,EAAmBnD,KAAKyE,IAAIzE,KAAK0E,MAAMzB,EAA4B,IAAQT,EAAQZ,SACrFwB,EAAWF,EAAqBC,EAC9BD,EACAC,GAESX,EAAQb,YACnByB,EAAWZ,EAAQb,YAEdyB,EAAWZ,EAAQd,cACxB0B,EAAWZ,EAAQd,a,kBAGhB,IAAIpE,SAAQ,SAACC,EAASC,GASzB,IAAImH,EAP+B,IAA/B7B,GAAiE,IAA7BG,GAEpC1F,GAAQ,GAGZkD,EAAiBM,OAAOzB,EAAgBf,SAAS,GAIjD,IAAMsC,EAAkB,WACpB+D,IACAC,qBAAqBF,GAErBpH,GAAQ,E,EAIZkD,EAAiBG,IAAItB,EAAgBf,QAASsC,GAE9C,IACMiE,EAAUtC,EAAQlB,mBAClBT,EAFwB,SAAChD,G,OAAMA,EAAEkH,gB,EAKjCC,EAAexC,EAAQlB,mBACvB,CAAE2D,SAAS,GACX,CAAEA,SAAS,GACXC,EAAS,CAAC,QAAS,aAAc,UAAW,aAE5CN,EAAkB,WACpBM,EAAOC,SAAQ,SAACC,GACZ9F,EAAgBf,QAAQ8G,oBAAoBD,EAAWN,EAASE,E,KAIxEE,EAAOC,SAAQ,SAACC,GACZ9F,EAAgBf,QAAQ+G,iBAAiBF,EAAWN,EAASE,E,IAGjE,IAAMO,EAAeC,KAAKC,MACpB9H,EAAO,WACT,IAAI+H,EAAWF,KAAKC,MAAQF,EACxB/D,EAAIkE,EAAWtC,EACbuC,EAA2B3F,KAAK0E,MAAM7B,EACxCC,EAA6BN,EAAQjB,OAAOC,IAC1CoE,EAAyB5F,KAAK0E,MAAM1B,EAAwBC,EAA2BT,EAAQjB,OAAOC,IACxGkE,EAAWtC,IACVuC,IAA6BpG,GAAKqG,IAA2BpG,IAG9DF,EAAgBkB,SAASmF,EAA0BC,GAEnDjB,EAAYkB,sBAAsBlI,KAMlC2B,EAAgBkB,SAASjB,EAAGC,GAC5BqF,qBAAqBF,GAErBC,IAEAnE,EAAiBM,OAAOzB,EAAgBf,SAAS,GAEjDhB,GAAQ,G,EAIhBoH,EAAYkB,sBAAsBlI,E","sources":["node_modules/animated-scroll-to/dist/esm/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// --------- HELPERS\nfunction getElementOffset(el) {\n    let top = 0;\n    let left = 0;\n    let element = el;\n    // Loop through the DOM tree\n    // and add it's parent's offset to get page offset\n    do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n    } while (element);\n    return {\n        top,\n        left,\n    };\n}\n// --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\nclass ScrollDomElement {\n    constructor(element) {\n        this.element = element;\n    }\n    getHorizontalScroll() {\n        return this.element.scrollLeft;\n    }\n    getVerticalScroll() {\n        return this.element.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return this.element.scrollWidth - this.element.clientWidth;\n    }\n    getMaxVerticalScroll() {\n        return this.element.scrollHeight - this.element.clientHeight;\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).left -\n            getElementOffset(elementToScroll).left);\n    }\n    getVerticalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).top -\n            getElementOffset(elementToScroll).top);\n    }\n    scrollTo(x, y) {\n        this.element.scrollLeft = x;\n        this.element.scrollTop = y;\n    }\n}\nclass ScrollWindow {\n    constructor() {\n        this.element = window;\n    }\n    getHorizontalScroll() {\n        return window.scrollX || document.documentElement.scrollLeft;\n    }\n    getVerticalScroll() {\n        return window.scrollY || document.documentElement.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return (Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth);\n    }\n    getMaxVerticalScroll() {\n        return (Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight);\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo) {\n        const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n    }\n    getVerticalElementScrollOffset(elementToScrollTo) {\n        const scrollTop = window.scrollY || document.documentElement.scrollTop;\n        return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n    }\n    scrollTo(x, y) {\n        window.scrollTo(x, y);\n    }\n}\nconst activeAnimations = {\n    elements: [],\n    cancelMethods: [],\n    add: (element, cancelAnimation) => {\n        activeAnimations.elements.push(element);\n        activeAnimations.cancelMethods.push(cancelAnimation);\n    },\n    remove: (element, shouldStop) => {\n        const index = activeAnimations.elements.indexOf(element);\n        if (index > -1) {\n            // Stop animation\n            if (shouldStop) {\n                activeAnimations.cancelMethods[index]();\n            }\n            // Remove it\n            activeAnimations.elements.splice(index, 1);\n            activeAnimations.cancelMethods.splice(index, 1);\n        }\n    },\n};\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n// --------- ANIMATE SCROLL TO\nconst defaultOptions = {\n    cancelOnUserAction: true,\n    easing: (t) => --t * t * t + 1,\n    elementToScroll: WINDOW_EXISTS ? window : null,\n    horizontalOffset: 0,\n    maxDuration: 3000,\n    minDuration: 250,\n    speed: 500,\n    verticalOffset: 0,\n};\nfunction animateScrollTo(numberOrCoordsOrElement, userOptions = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Check for server rendering\n        if (!WINDOW_EXISTS) {\n            // @ts-ignore\n            // If it still gets called on server, return Promise for API consistency\n            return new Promise((resolve) => {\n                resolve(false); // Returning false on server\n            });\n        }\n        else if (!window.Promise) {\n            throw \"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.\";\n        }\n        let x;\n        let y;\n        let scrollToElement;\n        let options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n        const isWindow = options.elementToScroll === window;\n        const isElement = !!options.elementToScroll.nodeName;\n        if (!isWindow && !isElement) {\n            throw 'Element to scroll needs to be either window or DOM element.';\n        }\n        // Check for \"scroll-behavior: smooth\" as it can break the animation\n        // https://github.com/Stanko/animated-scroll-to/issues/55\n        const scrollBehaviorElement = isWindow\n            ? document.documentElement\n            : options.elementToScroll;\n        const scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n        if (scrollBehavior === 'smooth') {\n            console.warn(`${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`);\n        }\n        // Select the correct scrolling interface\n        const elementToScroll = isWindow\n            ? new ScrollWindow()\n            : new ScrollDomElement(options.elementToScroll);\n        if (numberOrCoordsOrElement instanceof Element) {\n            scrollToElement = numberOrCoordsOrElement;\n            // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n            if (isElement &&\n                (!options.elementToScroll.contains(scrollToElement) ||\n                    options.elementToScroll.isSameNode(scrollToElement))) {\n                throw 'options.elementToScroll has to be a parent of scrollToElement';\n            }\n            x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n            y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n        }\n        else if (typeof numberOrCoordsOrElement === 'number') {\n            x = elementToScroll.getHorizontalScroll();\n            y = numberOrCoordsOrElement;\n        }\n        else if (Array.isArray(numberOrCoordsOrElement) &&\n            numberOrCoordsOrElement.length === 2) {\n            x =\n                numberOrCoordsOrElement[0] === null\n                    ? elementToScroll.getHorizontalScroll()\n                    : numberOrCoordsOrElement[0];\n            y =\n                numberOrCoordsOrElement[1] === null\n                    ? elementToScroll.getVerticalScroll()\n                    : numberOrCoordsOrElement[1];\n        }\n        else {\n            // ERROR\n            throw ('Wrong function signature. Check documentation.\\n' +\n                'Available method signatures are:\\n' +\n                '  animateScrollTo(y:number, options)\\n' +\n                '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n                '  animateScrollTo(scrollToElement:Element, options)');\n        }\n        // Add offsets\n        x += options.horizontalOffset;\n        y += options.verticalOffset;\n        // Horizontal scroll distance\n        const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n        const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (x > maxHorizontalScroll) {\n            x = maxHorizontalScroll;\n        }\n        // Calculate distance to scroll\n        const horizontalDistanceToScroll = x - initialHorizontalScroll;\n        // Vertical scroll distance distance\n        const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n        const initialVerticalScroll = elementToScroll.getVerticalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (y > maxVerticalScroll) {\n            y = maxVerticalScroll;\n        }\n        // Calculate distance to scroll\n        const verticalDistanceToScroll = y - initialVerticalScroll;\n        // Calculate duration of the scroll\n        const horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n        const verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n        let duration = horizontalDuration > verticalDuration\n            ? horizontalDuration\n            : verticalDuration;\n        // Set minimum and maximum duration\n        if (duration < options.minDuration) {\n            duration = options.minDuration;\n        }\n        else if (duration > options.maxDuration) {\n            duration = options.maxDuration;\n        }\n        // @ts-ignore\n        return new Promise((resolve, reject) => {\n            // Scroll is already in place, nothing to do\n            if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n                // Resolve promise with a boolean hasScrolledToPosition set to true\n                resolve(true);\n            }\n            // Cancel existing animation if it is already running on the same element\n            activeAnimations.remove(elementToScroll.element, true);\n            // To cancel animation we have to store request animation frame ID\n            let requestID;\n            // Cancel animation handler\n            const cancelAnimation = () => {\n                removeListeners();\n                cancelAnimationFrame(requestID);\n                // Resolve promise with a boolean hasScrolledToPosition set to false\n                resolve(false);\n            };\n            // Registering animation so it can be canceled if function\n            // gets called again on the same element\n            activeAnimations.add(elementToScroll.element, cancelAnimation);\n            // Prevent user actions handler\n            const preventDefaultHandler = (e) => e.preventDefault();\n            const handler = options.cancelOnUserAction\n                ? cancelAnimation\n                : preventDefaultHandler;\n            // If animation is not cancelable by the user, we can't use passive events\n            const eventOptions = options.cancelOnUserAction\n                ? { passive: true }\n                : { passive: false };\n            const events = ['wheel', 'touchstart', 'keydown', 'mousedown'];\n            // Function to remove listeners after animation is finished\n            const removeListeners = () => {\n                events.forEach((eventName) => {\n                    elementToScroll.element.removeEventListener(eventName, handler, eventOptions);\n                });\n            };\n            // Add listeners\n            events.forEach((eventName) => {\n                elementToScroll.element.addEventListener(eventName, handler, eventOptions);\n            });\n            // Animation\n            const startingTime = Date.now();\n            const step = () => {\n                var timeDiff = Date.now() - startingTime;\n                var t = timeDiff / duration;\n                const horizontalScrollPosition = Math.round(initialHorizontalScroll +\n                    horizontalDistanceToScroll * options.easing(t));\n                const verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));\n                if (timeDiff < duration &&\n                    (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n                    // If scroll didn't reach desired position or time is not elapsed\n                    // Scroll to a new position\n                    elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n                    // And request a new step\n                    requestID = requestAnimationFrame(step);\n                }\n                else {\n                    // If the time elapsed or we reached the desired offset\n                    // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n                    // Clear animation frame to be sure\n                    elementToScroll.scrollTo(x, y);\n                    cancelAnimationFrame(requestID);\n                    // Remove listeners\n                    removeListeners();\n                    // Remove animation from the active animations coordinator\n                    activeAnimations.remove(elementToScroll.element, false);\n                    // Resolve promise with a boolean hasScrolledToPosition set to true\n                    resolve(true);\n                }\n            };\n            // Start animating scroll\n            requestID = requestAnimationFrame(step);\n        });\n    });\n}\nexport default animateScrollTo;\n"],"names":["$8MBJY","parcelRequire","$1c5ec8b4351730db$var$__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","$1c5ec8b4351730db$var$getElementOffset","el","top","left","element","offsetTop","offsetLeft","offsetParent","$1c5ec8b4351730db$var$ScrollDomElement","ScrollDomElement","this","key","scrollLeft","scrollTop","scrollWidth","clientWidth","scrollHeight","clientHeight","elementToScrollTo","elementToScroll","x","y","$1c5ec8b4351730db$var$ScrollWindow","ScrollWindow","window","scrollX","document","documentElement","scrollY","Math","max","body","offsetWidth","innerWidth","offsetHeight","innerHeight","getBoundingClientRect","scrollTo","$1c5ec8b4351730db$var$activeAnimations","elements","cancelMethods","add","cancelAnimation","push","remove","shouldStop","index","indexOf","splice","$1c5ec8b4351730db$var$WINDOW_EXISTS","$1c5ec8b4351730db$var$defaultOptions","cancelOnUserAction","easing","t","horizontalOffset","maxDuration","minDuration","speed","verticalOffset","$1c5ec8b4351730db$export$2e2bcd8739ae039","numberOrCoordsOrElement","userOptions","arguments","length","$parcel$interopDefault","$2TvXO","mark","_callee","scrollToElement","options","isWindow","isElement","scrollBehaviorElement","maxHorizontalScroll","initialHorizontalScroll","horizontalDistanceToScroll","maxVerticalScroll","initialVerticalScroll","verticalDistanceToScroll","horizontalDuration","verticalDuration","duration","Object","assign","nodeName","getComputedStyle","getPropertyValue","console","warn","concat","tagName","Element","contains","isSameNode","getHorizontalElementScrollOffset","getVerticalElementScrollOffset","getHorizontalScroll","Array","isArray","getVerticalScroll","getMaxHorizontalScroll","getMaxVerticalScroll","abs","round","requestID","removeListeners","cancelAnimationFrame","handler","preventDefault","eventOptions","passive","events","forEach","eventName","removeEventListener","addEventListener","startingTime","Date","now","timeDiff","horizontalScrollPosition","verticalScrollPosition","requestAnimationFrame"],"version":3,"file":"index.820b1866.js.map"}